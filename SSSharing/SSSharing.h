#ifndef SSSHARING_H
#define SSSHARING_H

#include <NTL/vec_ZZ_p.h>
#include <NTL/ZZ_pX.h>
#include <NTL/ZZ_p.h>
#include <vector>
#include <tuple>
#include <iostream>


/// @brief 
/// This class implements the Shamir Secret Sharing Scheme. It is used to generate shares of a secret and to reconstruct the secret from the shares. 
/// How Shamir Secret Sharing works can be read here: https://de.wikipedia.org/wiki/Shamir%E2%80%99s_Secret_Sharing
/// 
/// The class has two functions:
/// - generateShares: This function generates shares of a secret. It takes the number of shares to generate, the secret, the size of the secret and the modulus q as input. It returns a tuple of the shares and the x values of the shares.
/// - printAndVeryfyShares: This function prints the shares and verifies the reconstruction of the secret from the shares. It takes the shares, the number of shares, the size of the secret and the modulus q as input. This function is only used for testing purposes.
/// - reconstructPartialSecret: This function reconstructs the secret from the shares. It takes one share and the x values of the shares as input and returns a partial reconstructed secret.
///
namespace SSSharing{


    /// @brief Function to generate shares of a secret
    /// @param numberOfShares The number of shares to generate
    /// @param secret The secret as a vector of ZZ_p
    /// @param secretSizeOfFiles Length of the secret
    /// @param mod_q Modulus q
    /// @return Tuple(all x values, server1 y values, server2 y values)
    inline std::tuple<std::vector<NTL::vec_ZZ_p>, NTL::vec_ZZ_p, NTL::vec_ZZ_p> generateShares(const int& numberOfShares, NTL::vec_ZZ_p secret, const int& secretSizeOfFiles,const int &mod_q){
        NTL::ZZ_p::init(NTL::ZZ(mod_q));
        std::vector<NTL::vec_ZZ_p> x;
        NTL::vec_ZZ_p server1y;
        NTL::vec_ZZ_p server2y;

        for(int i = 0; i < secretSizeOfFiles; i++){
            NTL::ZZ_pX poly;
            NTL::vec_ZZ_p coefficients;
            coefficients.SetLength(numberOfShares-1);
            NTL::SetCoeff(poly, 0, secret[i]);
            for(int j = 0; j < numberOfShares-1; j++){
                coefficients[j] = NTL::random_ZZ_p();
                NTL::SetCoeff(poly, j+1, coefficients[j]);
            }
            NTL::vec_ZZ_p shares;
            shares.SetLength(numberOfShares);
            NTL::vec_ZZ_p x_i;
            x_i.SetLength(numberOfShares);
            for(int j = 0; j < numberOfShares; j++){
                x_i[j] = NTL::random_ZZ_p();
            }
            for(int j = 0; j < numberOfShares; j++){
                shares[j] = NTL::eval(poly, x_i[j]);
            }
            x.push_back(x_i);
            server1y.append(shares[0]);
            server2y.append(shares[1]);
        }

        /* print all secrets
        for(int i = 0; i < secretSizeOfFiles; i++){
            std::cout << "Server 1 secret " << i << " : " << server1y[i] << std::endl;
            std::cout << "Server 2 secret " << i << " : " << server2y[i] << std::endl;
        }
        */

        return std::make_tuple(x, server1y, server2y);
    }

    /// @brief Function to check the shares and verify the reconstruction of the secret
    /// @param secrets Tuple of the shares generated by the function generateShares
    /// @param numberOfShares The number of shares
    /// @param secretSizeOfFiles Length of the secret
    /// @param mod_q Modulus q
    inline void printAndVeryfyShares(const std::tuple<std::vector<NTL::vec_ZZ_p>, NTL::vec_ZZ_p, NTL::vec_ZZ_p>& secrets, const int& numberOfShares, const int& secretSizeOfFiles, const int& mod_q){
        NTL::ZZ_p::init(NTL::ZZ(mod_q));
        std::vector<NTL::vec_ZZ_p> x = std::get<0>(secrets);
        NTL::vec_ZZ_p server1y = std::get<1>(secrets);
        NTL::vec_ZZ_p server2y = std::get<2>(secrets);
        std::vector<NTL::vec_ZZ_p> y = {server1y, server2y};
        NTL::vec_ZZ_p reconstructedSecrets;
        for(int i = 0; i < secretSizeOfFiles; i++){
            NTL::ZZ_p reconstructedSecretK;
            for(size_t j = 0; j < y.size(); j++){
                NTL::ZZ_p partOfX = NTL::ZZ_p(1);
                for(long int k = 0; k < x[i].length(); k++){
                    if (k == static_cast<long int>(j)) continue;  
                    partOfX *= (x[i][k] / (x[i][k] - x[i][j]));
                }
                reconstructedSecretK += y[j][i] * partOfX;
            }
            std::cout << "Reconstructed secret " << i << " : " << reconstructedSecretK << std::endl;
        }
    }

    /// @brief Reconstruction of the partial secrets. Because each server does only know his y values and the x values of all servers, the final summation is part of the addition of the tau's.
    /// @param xes Vector of all x values
    /// @param y Y values of the server
    /// @param numberOfShares The number of shares
    /// @param secretSizeOfFiles Length of the secret
    /// @param mod_q Modulus q
    /// @param serverNumber Numer of the server to identify the belonging x to the y
    /// @return Vector of the partial reconstructed secrets
    inline NTL::vec_ZZ_p reconstructPartialSecret(const std::vector<NTL::vec_ZZ_p>& xes, const NTL::vec_ZZ_p& y, const int& numberOfShares, const int& secretSizeOfFiles, const int& mod_q, const int& serverNumber){
        NTL::ZZ_p::init(NTL::ZZ(mod_q));
        NTL::vec_ZZ_p reconstructedSecrets;
        NTL::ZZ_p partialSecretK;
        NTL::vec_ZZ_p x;
        NTL::ZZ_p y_i;
        NTL::ZZ_p partOfX;
        for(int i = 0; i < secretSizeOfFiles; i++){
            x = xes[i];
            y_i = y[i];
            partOfX = NTL::ZZ_p(1);
            for(long int j = 0; j < x.length(); j++){
                if (j == static_cast<long int>(serverNumber)) continue;  
                partOfX *= (x[j] / (x[j] - x[serverNumber]));
            }
            partialSecretK =  y_i * partOfX;
            reconstructedSecrets.append(partialSecretK);
        }

        /* // print reconstructed secrets
        for(int i = 0; i < secretSizeOfFiles; i++){
            std::cout << "Reconstructed secret " << i << " : " << reconstructedSecrets[i] << std::endl;
        }
        */
        return reconstructedSecrets;
    }
}


#endif // SSSHARING_H
