// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.

use methods::{PUB_KEY_SERVER_PROOF_GUEST_ELF, PUB_KEY_SERVER_PROOF_GUEST_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use std::{error::Error, fs, path::PathBuf, env};



fn main() -> Result<(), Box<dyn Error>>{

    // use executable as: ./prover m l k data_path proof_path
    let args: Vec<String> = env::args().collect();

    let m : usize = args[1].parse().unwrap();
    let l : usize = args[2].parse().unwrap();
    let k : usize = args[3].parse().unwrap();
    let data_path = &args[4];
    let proof_path = &args[5];


    //println!("m: {}", m);
    //println!("l: {}", l);
    //println!("k: {}", k);
    //println!("data_path: {}", data_path);


    let data = fs::read_to_string(PathBuf::from(data_path))?;
    // include_str!("../../res/DataServer1.json");

    // Parse the JSON data to vector
    let data = json::parse(&data).unwrap();
    	
    // a [row_n][col_k] matrix
    let mut a : Vec<Vec<u32>> = Vec::new();
    let mut b_i : Vec<Vec<u32>> = Vec::new();
    let mut e_i : Vec<Vec<u32>> = Vec::new();
    let mut s_i : Vec<Vec<u32>> = Vec::new();

    let e_small : u32 = data["e_small"].as_u32().unwrap();
    let s_small : u32 = data["s_small"].as_u32().unwrap();

    for i in 0..k{
        let mut row : Vec<u32> = Vec::new();
        for j in 0..k{
            row.push(data["A"][i][j].as_u32().unwrap());
        }
        a.push(row);
    }

    for i in 0..m*l{
        let mut row_b : Vec<u32> = Vec::new();
        let mut row_e : Vec<u32> = Vec::new();
        let mut row_s : Vec<u32> = Vec::new();
        for j in 0..k{
            row_b.push(data["b_i"][i][j].as_u32().unwrap());
            row_e.push(data["e_i"][i][j].as_u32().unwrap());
            row_s.push(data["s_i"][i][j].as_u32().unwrap());
        }
        b_i.push(row_b);
        e_i.push(row_e);
        s_i.push(row_s);
    }

    // println!("  {:?}", a);
    // println!("  {:?}", b_i);
    // println!("  {:?}", e_i);
    // println!("  {:?}", s_i);
    // println!("  {:?}", e_small);
    // println!("  {:?}", s_small);

    let input : (Vec<Vec<u32>>, Vec<Vec<u32>>, Vec<Vec<u32>>, u32, u32) = (a, e_i, s_i, e_small, s_small);
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove_elf(env, PUB_KEY_SERVER_PROOF_GUEST_ELF).unwrap();


    let outputs: Vec<Vec<u32>> = receipt.journal.decode().unwrap();

    let result_check = outputs == b_i;

    println!("Result check: {}", result_check);
    println!("DS proof run successfully!");
    // println!("Outputs: {:?}", outputs);
    
    let output_path = PathBuf::from(proof_path);
    fs::write(output_path, bincode::serialize(&receipt).unwrap())?;

    // Verify the receipt file.
    receipt.verify(PUB_KEY_SERVER_PROOF_GUEST_ID).expect("Verification failed!");

    println!("DS proof verified successfully!");

    Ok(())

}
