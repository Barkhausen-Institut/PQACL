// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    ACCESS_CONTROL_PROOF_GUEST_ELF, ACCESS_CONTROL_PROOF_GUEST_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};
use std::{error::Error, fs, path::PathBuf, env};



fn main() -> Result<(), Box<dyn Error>>{

    // use executable as: ./prover n m l k data_path proof_path
    let args: Vec<String> = env::args().collect();

    let n : usize = args[1].parse().unwrap();
    let m : usize = args[2].parse().unwrap();
    let l : usize = args[3].parse().unwrap();
    let k : usize = args[4].parse().unwrap();
    let data_path = &args[5];
    let proof_path = &args[6];

    //println!("n: {}", n);
    //println!("m: {}", m);
    //println!("l: {}", l);
    //println!("k: {}", k);
    //println!("data_path: {}", data_path);


    let data = fs::read_to_string(PathBuf::from(data_path))?;

    // Parse the JSON data to vector
    let data = json::parse(&data).unwrap();
    	
    // a [row_n][col_k] matrix
    let mut a : Vec<Vec<u32>> = Vec::new();
    let mut b : Vec<Vec<u32>> = Vec::new();
    let mut e_1 : Vec<u32> = Vec::new();
    let mut e_2 : Vec<u32> = Vec::new();
    let mut priv_key : Vec<u32> = Vec::new();
    let mut r : Vec<u32> = Vec::new();
    let mut c_1 : Vec<u32> = Vec::new();
    let mut c_2 : Vec<u32> = Vec::new();
    let e_small : u32 = data["e_small"].as_u32().unwrap();
    let s_small : u32 = data["s_small"].as_u32().unwrap();



    for i in 0..k{
        r.push(data["r"][i].as_u32().unwrap());
        c_1.push(data["c_1"][i].as_u32().unwrap());
        e_1.push(data["e_1"][i].as_u32().unwrap());
        let mut row_a : Vec<u32> = Vec::new();
        for j in 0..k{
            row_a.push(data["A"][i][j].as_u32().unwrap());
        }
        a.push(row_a);

    }

    for i in 0..n*m*l{
        priv_key.push(data["priv_key"][i].as_u32().unwrap());
        c_2.push(data["c_2"][i].as_u32().unwrap());
        e_2.push(data["e_2"][i].as_u32().unwrap());

        let mut row_b : Vec<u32> = Vec::new();
        for j in 0..k{
            row_b.push(data["B"][i][j].as_u32().unwrap());
        }
        b.push(row_b);

    }

    // println!("  {:?}", a);
    // println!("  {:?}", b);
    // println!("  {:?}", e_1);
    // println!("  {:?}", e_2);
    // println!("  {:?}", priv_key);
    // println!("  {:?}", r);
    // println!("  {:?}", c_1);
    // println!("  {:?}", c_2);



    let input : (Vec<Vec<u32>>, Vec<Vec<u32>>, Vec<u32>, Vec<u32>, Vec<u32>, Vec<u32>, u32, u32) = (a, b, e_1, e_2, priv_key, r, e_small, s_small);
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove_elf(env, ACCESS_CONTROL_PROOF_GUEST_ELF).unwrap();


    let (c_1_out, c_2_out): (Vec<u32>, Vec<u32>) = receipt.journal.decode().unwrap();


    let result_check_1 = c_1_out == c_1;
    let result_check_2 = c_2_out == c_2;

    println!("Result check c_1: {}", result_check_1);
    println!("Result check c_2: {}", result_check_2);

    println!("Access control proof run successfully!");
    //println!("C_1: {:?}", c_1_out);
    // println!("C_2: {:?}", c_2_out);
    
    let output_path = PathBuf::from(proof_path);
    fs::write(output_path, bincode::serialize(&receipt).unwrap())?;

    // Verify the receipt file.
    receipt.verify(ACCESS_CONTROL_PROOF_GUEST_ID).expect("Verification failed!");

    println!("Access control proof verified successfully!");

    Ok(())

}
